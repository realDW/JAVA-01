####第7课作业

见code

#### 第八课作业

1. [列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。](doc/1.md)

2. 请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的？ 

   答：多线程通过**切分时间片共享CPU资源的执行方式**进行执行的操作称之为并发。多个线程同一段内一起执行CPU 资源是有限的，但是通过CPU快速切换上下文的方式实现多线程在同一时间内“同时执行”。

   高并发描述的一个性能指标，指的是在同一时间系统能并行并发的处理比较多的请求。具体多少算多得根据实际的业务场景来判断。高并发有几个主要的指标，系统的 RPS（request per second），QPS（query per second），吞吐量，系统延迟等。

   

3. 还有哪些跟并发类似/有关的场景和问题，有哪些可以借鉴的解决办法。

   答：并发的问题归根到底就是可见性、原子性和有序性的问题，这有些数据库中的ACID。和**并发场景最相似的场景便是数据库的事务场景**。数据库中的乐观锁也是基于CAS进行高效的并发处理。在事务中每一条数据的修改都是互斥的，对每个数据的读都是共享的这很细那个JUC中的ReadWriteLock 读写锁。数据库中的 MVCC 多版本并发控制，当开启一个事务后都会生成一个事务Id，来解决事务的可见性问题，这是一个很棒的解决思路，可以快速的来给整个数据定一个快照。如果在我们并发场景中，并发处理的数据资源总量不是很大的话，并没有完全的必要去使用这种方式，因为使用版本使用，版本号的方式相当于是把并发版本确认的操作成本平摊到每次的并发数据操作中了。数据量不大的话，完全可以使用 copy 的方式直接复制一份进行操作。

   **String， Integer，Long 等包装类利用不变性解决并发并发问题**，也是一个很好的解决并发问题的方案。String 内部有一个 final 的 char[] value，当这个String 创建之后，这个final类型的对象就是不可变的了，String 的 “+” 操作 在编译字节码操作也是 StringBuffer 进行操作，返回的也是一个新的对象，String中的其他方法例如 replace subtring 等，返回的都是一个新的字符串。如果不是修改同一个对象也就不存在并发问题了。

   **Copy-on-write也是一个不错的并发设计思路** ，读的时候是不存在并发问题的，数据上的并发问题只有在写的时候存在，所以我们在在修改的时候先拷贝一份修改完了写回去。CAS 也是这么个思路，还有 String, Long, Integer 等包装类修改时候使用的策略。但是这个设计模式有个缺点就是比较耗费内存，如果复制的资源很庞大，那么复制一份将占用大量的内存资源，所以数据库并发版本控制适合使用版本号而不是COW。

    上面都是从资源的角度去尝试无锁的解决并发问题。**如果从始至终都只有一个线程操作的话，从并发问题的根源也就避免了并发问题。**例如ThreadLocal 的实现，同理我们把变量写在方法内部不让数据共享，也就避免了并发的问题。

   

4. 把多线程和并发相关知识带你梳理一遍，画一个脑图，截图上传到 Github上。

![image-20210206183102504](/Users/daiwei/study/java-homework-repo/JAVA-01/Week_04/img/thread_mind.png)